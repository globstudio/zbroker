<class
    name = "zpipes_server"
    title = "ZPIPES server"
    proto = "zpipes_msg"
    script = "zproto_server_c"
    header = "../include"
    >
    This is a server implementation for the ZPIPES protocol
    <include filename = "license.xml" />

    <!-- State machine for a client connection -->
    <state name = "start">
        <event name = "input" next = "reading">
            <action name = "open pipe for input" />
            <action name = "send" message = "input ok" />
        </event>
        <event name = "output" next = "writing">
            <action name = "open pipe for output" />
            <action name = "send" message = "output ok" />
        </event>
    </state>

    This state allows two protocol commands, read and close:

    <state name = "reading">
        <event name = "read" next = "expecting chunk">
            <action name = "expect chunk on pipe" />
        </event>
        <event name = "close">
            <action name = "close pipe" />
            <action name = "send" message = "close ok" />
            <action name = "terminate" />
        </event>
    </state>

    This internal state shows how we make a decision in the
    state machine. These are three internal events; they can
    happen come immediately from 'expect chunk on pipe', or
    come later from various places. The server can ask for a
    wakeup event (timeout expired). We can also get events
    from other clients' machines.

    <state name = "expecting chunk">
        <event name = "have chunk" next = "reading">
            <action name = "clear pending reads" />
            <action name = "fetch chunk from pipe" />
            <action name = "send" message = "read ok" />
        </event>
        <event name = "pipe terminated" next = "reading">
            <action name = "clear pending reads" />
            <action name = "send" message = "end of pipe" />
        </event>
        <event name = "timeout expired" next = "reading">
            <action name = "clear pending reads" />
            <action name = "send" message = "timeout" />
        </event>
    </state>
    
    <state name = "writing">
        <event name = "write" next = "writing">
            <action name = "store chunk to pipe" />
            <action name = "send" message = "write ok" />
        </event>
        <event name = "close">
            <action name = "close pipe" />
            <action name = "send" message = "close ok" />
            <action name = "terminate" />
        </event>
    </state>

    The defaults state handles an 'exception_event' (sends
    'failed' back to the client). It also specifies that any
    unrecognized protocol command (an '$other' event) will
    also cause the engine to send 'failed' back to the client.

    <state name = "defaults">
        <event name = "exception">
            <action name = "send" message = "failed" />
            <action name = "terminate" />
        </event>
        <event name = "$other">
            <action name = "send" message = "failed" />
        </event>
    </state>

    We can define API methods to pass commands back from the
    application through to the engine.

    <!-- API methods
    <method name = "somename" return = "number">
        One-line description of method here
        <argument name = "some value" type = "string">What is this argument?</argument>
        <argument name = "some value" type = "number">What is this argument?</argument>
    </method>
    -->
</class>
